
int main()
{
	FILE *fp;		// 평문 파일을 생성하고 이용하기 위한 변수
	FILE *fpenc;    // 파일을 암호화한 파일을 저장하기 위한 변수
	FILE *fpg;		// 암호문을 다시 열기 위한 변수
	FILE *fpdec;	// 복호화한 값을 저장하기 위한 변수

	int i, length=0;
	int msg_len = 0, block_count = 0;
	int ans;
	BYTE p_text[128] = { 0, }; // 평문에 대한 변수
	BYTE key[Nk * 4 + 1] = { 0, }; // 키에 대한 변수
	BYTE c_text[128] = { 0, }; // p_text에 있는 값을 암호화
	BYTE c1_text[128] = { 0, }; // storyenc를 읽어오기 위한 배열
	BYTE inv_c_text[128] = { 0, };


	fp = fopen("C:\\Users\\곽용구\\Desktop\\4조(평문).txt","w+");     // c_text에 있는 값을
	printf("평문을 입력하세요 : ");
	gets((char*)p_text);
	fputs((char*)p_text, fp);							     // 4조(평문)enc.txt에 쓰기
	fclose(fp);												     // fputs(출력할 변수명, 스트림)

	msg_len = (int)strlen((char*)p_text);      // 입력한 평문에 대한 길이

	printf("\n* 평문 : ");
	for (i = 0; i<msg_len; i++)	
		printf("%c", p_text[i]);
	printf("\n");											  

	printf("* 비밀키 입력 : ");
	scanf("%s", key);
	getchar();

	if((msg_len % (Nb*4)) > 0)							// 비트가 16의 배수가 아닌경우 빈공간을
	{													// 0으로 채워준다.
		block_count = (msg_len / (Nb*4)) + 1;
		for(i=msg_len; i<block_count*Nb*4; i++)
		{
			p_text[i] = '0';
		}
	}
	else
		block_count = msg_len / (Nb*4);					// 16비트일경우 block_count값 결정

	printf("\n* 보완된 평문 : ");						// 빈공간에 0을 넣어준 평문 값
	for (i = 0; i<block_count * Nb * 4; i++)  
		printf("%c", p_text[i]);
	printf("\n");

	// 암호화
	for (i = 0; i < block_count; i++)
		AES_Cipher(&p_text[i * Nb * 4], &c_text[i * Nb * 4], key);
												// w+는 파일이 존재하지 않는경우 생성후 쓰기
	fpenc = fopen("C:\\Users\\곽용구\\Desktop\\4조enc.txt","w+");     // c_text에 있는 값을
	fputs((char*)c_text, fpenc);					// 4조(평문)enc에 쓰기
	fclose(fpenc);							// fputs(출력할 변수명, 스트림)
	printf("\n* 암호문 : ");
	for (i = 0; i<block_count * Nb * 4; i++)
		printf("%c", c_text[i]);
	printf("\n");

	printf("복호문 파일을 생성하시겠습니까?(Y=1/N=2) : ");
	scanf("%d", &ans);
	if(ans==1)
	{
		// 복호화
		for (i = 0; i < block_count; i++)
			AES_Inverse_Cipher(&c_text[i * Nb * 4], &inv_c_text[i * Nb * 4], key);	

		if((msg_len % (Nb*4)) > 0)						// 복호화 된 값이 16 배수가 아닌경우 0값이 생기는 것을 NULL값으로 바꿔준다
		{
			block_count = (msg_len / (Nb*4)) + 1;
			for(i=msg_len; i<block_count*Nb*4; i++)		// 복호문은 빈공간을 설정할 필요가 없기 때문에
			{
				inv_c_text[i] = '\n';
			}
		}	
													// w+는 파일이 존재하지 않는경우 생성후 쓰기
		fpdec = fopen("C:\\Users\\곽용구\\Desktop\\4조dec.txt","w+");     // c_text에 있는 값을
		fputs((char*)inv_c_text, fpdec);							// 4조(평문)dec.txt에 쓰기
		fclose(fpdec);										// fputs(출력할 변수명, 스트림)
		printf("\n* 복호문 : ");
		for (i = 0; i<msg_len; i++)	
			printf("%c", inv_c_text[i]);
		printf("\n");	
	}
	else
	{
		printf("복호문 파일이 생성되지 않았습니다.\n");
		return 0;
	}
	
	void AES_Cipher(BYTE* in, BYTE* out, BYTE* key) // 암호화 함수
{
	int i, j;
	BYTE state[4][4];
	WORD* W;

	if (Nk == 4)
	{
		Nr = 10;
		W = (WORD*)malloc(sizeof(WORD)*Nb*(Nr + 1));
	}

	if (Nk == 6)
	{
		Nr = 12;
		W = (WORD*)malloc(sizeof(WORD)*Nb*(Nr + 1));
	}
 
	if (Nk == 8)
	{
		Nr = 14;
		W = (WORD*)malloc(sizeof(WORD)*Nb*(Nr + 1));
	}

	for (i = 0; i<4; i++)
		for (j = 0; j<4; j++)
			state[j][i] = in[i * 4 + j];

	KeyExpansion(key, W);	
	AddRoundKey(state, W);

	for (i = 0; i<Nr - 1; i++)
	{
		SubBytes(state);
		ShiftRows(state);
		MixColumns(state);
		AddRoundKey(state, &W[(i + 1) * 4]);
	}

	SubBytes(state);
	ShiftRows(state);
	AddRoundKey(state, &W[(i + 1) * 4]);
 
	for (i = 0; i<4; i++)
		for (j = 0; j<4; j++)
			out[i * 4 + j] = state[j][i];
	free(W);
}

void AES_Inverse_Cipher(BYTE* in, BYTE* out, BYTE* key) // 복호화 함수
{
	int i, j;
	BYTE state[4][4];
	WORD* W;

	if (Nk == 4)
	{
		Nr = 10;
		W = (WORD*)malloc(sizeof(WORD)*Nb*(Nr + 1));
	}
 
	if (Nk == 6)
	{
		Nr = 12;
		W = (WORD*)malloc(sizeof(WORD)*Nb*(Nr + 1));
	}

	if (Nk == 8)
	{
		Nr = 14;
		W = (WORD*)malloc(sizeof(WORD)*Nb*(Nr + 1));
	}
 
	for (i = 0; i<4; i++)
		for (j = 0; j<4; j++)
			state[j][i] = in[i * 4 + j];
 
	KeyExpansion(key, W);				
	AddRoundKey(state, &W[Nr*Nb]);										

	for (i = 0; i<Nr - 1; i++)
	{
		Inv_ShiftRows(state);
		Inv_SubBytes(state);
		AddRoundKey(state, &W[(Nr - i - 1)*Nb]);
		Inv_MixColumns(state);
	}
 
	Inv_ShiftRows(state);
	Inv_SubBytes(state);
	AddRoundKey(state, &W[(Nr - i - 1)*Nb]);

	for (i = 0; i<4; i++)
		for (j = 0; j<4; j++)
			out[i * 4 + j] = state[j][i];
	free(W);	
	}

}

void KeyExpansion(BYTE* key, WORD* W)   // 키 확장
{
	WORD temp;
	int i = 0;

	while (i < Nk)
	{
		W[i] = BTOW(key[4 * i], key[4 * i + 1], key[4 * i + 2], key[4 * i + 3]);
		i = i + 1;
	}

	i = Nk;

	while (i < (Nb * (Nr + 1)))
	{
		temp = W[i - 1];
		if (i % Nk == 0)
			temp = SubWord(RotWord(temp)) ^ Rcon[i / Nk - 1];
		else if ((Nk > 6) && (i % Nk == 4))
			temp = SubWord(temp);

		W[i] = W[i - Nk] ^ temp;
		i += 1;
	}
}

// SubWord
WORD SubWord(WORD W) // 키 확장을 위한 SubWord함수
{
	int i;
	WORD out = 0, mask = 0xFF000000;
	BYTE shift = 24;
 
	for (i = 0; i<4; i++)
	{
		out += (WORD)S_box[HIHEX((W & mask) >> shift)][LOWHEX((W & mask) >> shift)] << shift;
		mask >>= 8;
		shift -= 8;
	}
	return out;
}

WORD RotWord(WORD W) // 키 확장을 위한 RotWord함수 쉬프트연산
{
	return ((W & 0xFF000000) >> 24) | (W << 8);
}
 

void SubBytes(BYTE state[][4]) // 암호화를위한 라운드에 포함된 함수
{
	int i, j;

	for (i = 0; i<4; i++)
		for (j = 0; j<4; j++)
			state[i][j] = S_box[HIHEX(state[i][j])][LOWHEX(state[i][j])];
}
 

void ShiftRows(BYTE state[][4]) // 암호화를위한 라운드에 포함된 함수
{
	int i, j;
	for (i = 1; i<4; i++)
		for (j = 0; j<i; j++)
			CirShiftRows(state[i]);
}


void MixColumns(BYTE state[][4]) // 암호화를위한 라운드에 포함된 함수
{
	int i, j, k;
	BYTE a[4][4] = { 0x02, 0x03, 0x01, 0x01,		// a(x) = 03x^3 + 01x^2 + 01x + 02
		0x01, 0x02, 0x03, 0x01,
		0x01, 0x01, 0x02, 0x03,
		0x03, 0x01, 0x01, 0x02 };
	BYTE b[4][4] = { 0, };

	for (i = 0; i<4; i++)
	{
		for (j = 0; j<4; j++)
			for (k = 0; k<4; k++)
				b[i][j] ^= x_time_1(a[i][k], state[k][j]);	
	}

	for (i = 0; i<4; i++)
		for (j = 0; j<4; j++) state[i][j] = b[i][j];
}
